<!DOCTYPE html><html lang="en" style="font-size:16px"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Source: bluetooth.js</title><!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]--><script src="scripts/third-party/hljs.js" defer="defer"></script><script src="scripts/third-party/hljs-line-num.js" defer="defer"></script><script src="scripts/third-party/popper.js" defer="defer"></script><script src="scripts/third-party/tippy.js" defer="defer"></script><script src="scripts/third-party/tocbot.min.js"></script><script>var baseURL="/",locationPathname="";baseURL=(locationPathname=document.location.pathname).substr(0,locationPathname.lastIndexOf("/")+1)</script><link rel="stylesheet" href="styles/clean-jsdoc-theme.min.css"><svg aria-hidden="true" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" style="display:none"><defs><symbol id="copy-icon" viewbox="0 0 488.3 488.3"><g><path d="M314.25,85.4h-227c-21.3,0-38.6,17.3-38.6,38.6v325.7c0,21.3,17.3,38.6,38.6,38.6h227c21.3,0,38.6-17.3,38.6-38.6V124    C352.75,102.7,335.45,85.4,314.25,85.4z M325.75,449.6c0,6.4-5.2,11.6-11.6,11.6h-227c-6.4,0-11.6-5.2-11.6-11.6V124    c0-6.4,5.2-11.6,11.6-11.6h227c6.4,0,11.6,5.2,11.6,11.6V449.6z"/><path d="M401.05,0h-227c-21.3,0-38.6,17.3-38.6,38.6c0,7.5,6,13.5,13.5,13.5s13.5-6,13.5-13.5c0-6.4,5.2-11.6,11.6-11.6h227    c6.4,0,11.6,5.2,11.6,11.6v325.7c0,6.4-5.2,11.6-11.6,11.6c-7.5,0-13.5,6-13.5,13.5s6,13.5,13.5,13.5c21.3,0,38.6-17.3,38.6-38.6    V38.6C439.65,17.3,422.35,0,401.05,0z"/></g></symbol><symbol id="search-icon" viewBox="0 0 512 512"><g><g><path d="M225.474,0C101.151,0,0,101.151,0,225.474c0,124.33,101.151,225.474,225.474,225.474    c124.33,0,225.474-101.144,225.474-225.474C450.948,101.151,349.804,0,225.474,0z M225.474,409.323    c-101.373,0-183.848-82.475-183.848-183.848S124.101,41.626,225.474,41.626s183.848,82.475,183.848,183.848    S326.847,409.323,225.474,409.323z"/></g></g><g><g><path d="M505.902,476.472L386.574,357.144c-8.131-8.131-21.299-8.131-29.43,0c-8.131,8.124-8.131,21.306,0,29.43l119.328,119.328    c4.065,4.065,9.387,6.098,14.715,6.098c5.321,0,10.649-2.033,14.715-6.098C514.033,497.778,514.033,484.596,505.902,476.472z"/></g></g></symbol><symbol id="font-size-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M11.246 15H4.754l-2 5H.6L7 4h2l6.4 16h-2.154l-2-5zm-.8-2L8 6.885 5.554 13h4.892zM21 12.535V12h2v8h-2v-.535a4 4 0 1 1 0-6.93zM19 18a2 2 0 1 0 0-4 2 2 0 0 0 0 4z"/></symbol><symbol id="add-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M11 11V5h2v6h6v2h-6v6h-2v-6H5v-2z"/></symbol><symbol id="minus-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M5 11h14v2H5z"/></symbol><symbol id="dark-theme-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M10 7a7 7 0 0 0 12 4.9v.1c0 5.523-4.477 10-10 10S2 17.523 2 12 6.477 2 12 2h.1A6.979 6.979 0 0 0 10 7zm-6 5a8 8 0 0 0 15.062 3.762A9 9 0 0 1 8.238 4.938 7.999 7.999 0 0 0 4 12z"/></symbol><symbol id="light-theme-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M12 18a6 6 0 1 1 0-12 6 6 0 0 1 0 12zm0-2a4 4 0 1 0 0-8 4 4 0 0 0 0 8zM11 1h2v3h-2V1zm0 19h2v3h-2v-3zM3.515 4.929l1.414-1.414L7.05 5.636 5.636 7.05 3.515 4.93zM16.95 18.364l1.414-1.414 2.121 2.121-1.414 1.414-2.121-2.121zm2.121-14.85l1.414 1.415-2.121 2.121-1.414-1.414 2.121-2.121zM5.636 16.95l1.414 1.414-2.121 2.121-1.414-1.414 2.121-2.121zM23 11v2h-3v-2h3zM4 11v2H1v-2h3z"/></symbol><symbol id="reset-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M18.537 19.567A9.961 9.961 0 0 1 12 22C6.477 22 2 17.523 2 12S6.477 2 12 2s10 4.477 10 10c0 2.136-.67 4.116-1.81 5.74L17 12h3a8 8 0 1 0-2.46 5.772l.997 1.795z"/></symbol><symbol id="down-icon" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M12.7803 6.21967C13.0732 6.51256 13.0732 6.98744 12.7803 7.28033L8.53033 11.5303C8.23744 11.8232 7.76256 11.8232 7.46967 11.5303L3.21967 7.28033C2.92678 6.98744 2.92678 6.51256 3.21967 6.21967C3.51256 5.92678 3.98744 5.92678 4.28033 6.21967L8 9.93934L11.7197 6.21967C12.0126 5.92678 12.4874 5.92678 12.7803 6.21967Z"></path></symbol><symbol id="codepen-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M16.5 13.202L13 15.535v3.596L19.197 15 16.5 13.202zM14.697 12L12 10.202 9.303 12 12 13.798 14.697 12zM20 10.869L18.303 12 20 13.131V10.87zM19.197 9L13 4.869v3.596l3.5 2.333L19.197 9zM7.5 10.798L11 8.465V4.869L4.803 9 7.5 10.798zM4.803 15L11 19.131v-3.596l-3.5-2.333L4.803 15zM4 13.131L5.697 12 4 10.869v2.262zM2 9a1 1 0 0 1 .445-.832l9-6a1 1 0 0 1 1.11 0l9 6A1 1 0 0 1 22 9v6a1 1 0 0 1-.445.832l-9 6a1 1 0 0 1-1.11 0l-9-6A1 1 0 0 1 2 15V9z"/></symbol><symbol id="close-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M12 10.586l4.95-4.95 1.414 1.414-4.95 4.95 4.95 4.95-1.414 1.414-4.95-4.95-4.95 4.95-1.414-1.414 4.95-4.95-4.95-4.95L7.05 5.636z"/></symbol><symbol id="menu-icon" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"/><path d="M3 4h18v2H3V4zm0 7h18v2H3v-2zm0 7h18v2H3v-2z"/></symbol></defs></svg></head><body data-theme="dark"><div class="sidebar-container"><div class="sidebar" id="sidebar"><div class="sidebar-items-container"><div class="sidebar-section-title with-arrow" data-isopen="false" id="sidebar-classes"><div>Classes</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="BluetoothConnection.html">BluetoothConnection</a></div><div class="sidebar-section-children"><a href="ConnectionHandler.html">ConnectionHandler</a></div><div class="sidebar-section-children"><a href="ConnectionManager.html">ConnectionManager</a></div><div class="sidebar-section-children"><a href="DeviceSettings.html">DeviceSettings</a></div><div class="sidebar-section-children"><a href="EventEmitter.html">EventEmitter</a></div><div class="sidebar-section-children"><a href="GnssModule.html">GnssModule</a></div><div class="sidebar-section-children"><a href="NmeaParser.html">NmeaParser</a></div><div class="sidebar-section-children"><a href="NtripClient.html">NtripClient</a></div><div class="sidebar-section-children"><a href="RtkSettings.html">RtkSettings</a></div><div class="sidebar-section-children"><a href="RtkStatus.html">RtkStatus</a></div><div class="sidebar-section-children"><a href="Settings.html">Settings</a></div><div class="sidebar-section-children"><a href="SettingsPage.html">SettingsPage</a></div></div></div></div></div><div class="navbar-container" id="VuAckcnZhf"><nav class="navbar"><div class="navbar-left-items"></div><div class="navbar-right-items"><div class="navbar-right-item"><button class="icon-button search-button" aria-label="open-search"><svg><use xlink:href="#search-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button theme-toggle" aria-label="toggle-theme"><svg><use class="theme-svg-use" xlink:href="#light-theme-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button font-size" aria-label="change-font-size"><svg><use xlink:href="#font-size-icon"></use></svg></button></div></div><nav></nav></nav></div><div class="toc-container"><div class="toc-content"><span class="bold">On this page</span><div id="eed4d2a0bfd64539bb9df78095dec881"></div></div></div><div class="body-wrapper"><div class="main-content"><div class="main-wrapper"><section id="source-page" class="source-page"><header><h1 id="title" class="has-anchor">bluetooth.js</h1></header><article><pre class="prettyprint source lang-js"><code>/**
 * BluetoothConnection - Handles Web Bluetooth connections to GNSS receivers
 */
export class BluetoothConnection {
  constructor(eventEmitter, options = {}) {
    this.eventEmitter = eventEmitter;
    this.device = null;
    this.server = null;
    this.serialService = null;
    this.rxCharacteristic = null;
    this.txCharacteristic = null;
    this.isConnected = false;
    this.isConnecting = false;
    this.autoReconnect = false;
    this.connectionTimeout = 10000; // 10 seconds
    this.pollingEnabled = false;
    this.pollingInterval = null;
    
    // Debug settings
    this.debug = options.debug || { 
      info: false,
      debug: false,
      errors: true,
      parsedSentences: false,
      rtcmMessages: false
    };
    
    // Set up logger functions
    this.logger = {
      info: (...args) => {
        if (this.debug.info) {
          console.info('[BT-INFO]', ...args);
        }
      },
      debug: (...args) => {
        if (this.debug.debug) {
          console.debug('[BT-DEBUG]', ...args);
        }
      },
      error: (...args) => {
        if (this.debug.errors) {
          console.error('[BT-ERROR]', ...args);
        }
      },
      warn: (...args) => {
        if (this.debug.errors) {
          console.warn('[BT-WARN]', ...args);
        }
      }
    };
    
    // Common BLE UART/Serial service UUIDs
    // Prioritizing BLE services first since the Sparkfun Facet RTK Rover uses BLE
    this.SERVICE_UUIDS = [
      // BLE UART Services (most common)
      '6e400001-b5a3-f393-e0a9-e50e24dcca9e', // Nordic UART Service (nRF51822, very common in BLE devices)
      '0000ffe0-0000-1000-8000-00805f9b34fb', // Nordic UART Service (alternate form)
      '49535343-fe7d-4ae5-8fa9-9fafd205e455', // Common HM-10/HM-16/HM-17 BLE Module Service
      '0000fff0-0000-1000-8000-00805f9b34fb', // Common HC-08/HC-10 BLE Service
      
      // Generic BLE services that might be useful
      '00001801-0000-1000-8000-00805f9b34fb', // Generic Attribute Service
      '00001800-0000-1000-8000-00805f9b34fb', // Generic Access Service
      
      // SparkFun RTK-specific services (if they use custom services)
      '0000fe9a-0000-1000-8000-00805f9b34fb',  // Possible custom service
      
      // Legacy Classic Bluetooth services (less likely on BLE devices)
      '00001101-0000-1000-8000-00805f9b34fb', // SPP (Serial Port Profile) - Classic Bluetooth
      
      // Testing/fallback services
      '0000180d-0000-1000-8000-00805f9b34fb'  // Heart Rate Service (for testing)
    ];
    
    // Primary service (the first in our list)
    this.PRIMARY_SERVICE_UUID = this.SERVICE_UUIDS[0];
    
    // Common BLE characteristic UUIDs
    // Nordic UART (nRF UART) characteristic UUIDs - very common in BLE devices
    this.NORDIC_TX_UUID = '6e400002-b5a3-f393-e0a9-e50e24dcca9e'; // TX (device transmits to phone)
    this.NORDIC_RX_UUID = '6e400003-b5a3-f393-e0a9-e50e24dcca9e'; // RX (phone transmits to device)
    
    // Common alternate BLE characteristic UUIDs
    this.BLE_TX_UUIDS = [
      // Nordic UART variants
      '6e400002-b5a3-f393-e0a9-e50e24dcca9e', // Nordic TX
      '0000ffe1-0000-1000-8000-00805f9b34fb', // Common BLE TX
      '0000fff1-0000-1000-8000-00805f9b34fb', // HC-08 TX
      '49535343-8841-43f4-a8d4-ecbe34729bb3', // HM-10 TX
      // SparkFun might use a custom characteristic
      '0000fe9a-0002-1000-8000-00805f9b34fb'  // Possible custom TX
    ];
    
    this.BLE_RX_UUIDS = [
      // Nordic UART variants
      '6e400003-b5a3-f393-e0a9-e50e24dcca9e', // Nordic RX
      '0000ffe2-0000-1000-8000-00805f9b34fb', // Common BLE RX
      '0000fff2-0000-1000-8000-00805f9b34fb', // HC-08 RX
      '49535343-1e4d-4bd9-ba61-23c647249616', // HM-10 RX
      // SparkFun might use a custom characteristic
      '0000fe9a-0003-1000-8000-00805f9b34fb'  // Possible custom RX
    ];
    
    // Legacy names for backward compatibility 
    this.SPP_SERVICE_UUID = '00001101-0000-1000-8000-00805f9b34fb';
    this.SPP_RX_UUID = '00001102-0000-1000-8000-00805f9b34fb';
    this.SPP_TX_UUID = '00001103-0000-1000-8000-00805f9b34fb';
    
    // Bind methods
    this.onDisconnected = this.onDisconnected.bind(this);
  }

  /**
   * Connect to a GNSS receiver
   * @param {Object} options - Connection options
   * @returns {Promise&lt;boolean>} Whether connection was successful
   */
  async connect(options = {}) {
    if (this.isConnected) {
      return true;
    }
    
    if (this.isConnecting) {
      return false;
    }
    
    this.isConnecting = true;
    this.eventEmitter.emit('bluetooth:connecting', {});
    
    try {
      // Browser compatibility check
      if (!navigator.bluetooth) {
        throw new Error('Web Bluetooth API is not supported in this browser');
      }
      
      // Request device with optional filters
      const requestOptions = {
        acceptAllDevices: !options.filters,
        filters: options.filters || [],
        optionalServices: [this.SPP_SERVICE_UUID]
      };
      
      // Allow connecting to last device
      if (options.deviceId) {
        try {
          this.device = await navigator.bluetooth.getDevices()
            .then(devices => devices.find(d => d.id === options.deviceId));
            
          if (!this.device) {
            throw new Error('Device not found');
          }
        } catch (error) {
          console.warn('Failed to reconnect to known device:', error);
          // Fall back to device picker
          this.device = await navigator.bluetooth.requestDevice(requestOptions);
        }
      } else {
        // Show the device picker
        this.device = await navigator.bluetooth.requestDevice(requestOptions);
      }
      
      if (!this.device) {
        throw new Error('No device selected');
      }
      
      // Set up disconnection listener
      this.device.addEventListener('gattserverdisconnected', this.onDisconnected);
      
      // Connect to GATT server
      this.eventEmitter.emit('bluetooth:connecting', { step: 'gatt' });
      this.server = await this.device.gatt.connect();
      
      // Get a suitable UART/Serial service
      this.eventEmitter.emit('bluetooth:connecting', { step: 'service' });
      
      // First, get all services to see what's available
      const allServices = await this.server.getPrimaryServices();
      console.log('All available services:', allServices.map(s => s.uuid));
      
      if (allServices.length === 0) {
        throw new Error('No Bluetooth services found on this device');
      }
      
      // Then try to find one of our known UART services
      let foundService = null;
      let serviceUUID = '';
      
      // Try each of our known service UUIDs
      // BLE devices sometimes use shortened 16-bit UUIDs
      for (const uuid of this.SERVICE_UUIDS) {
        try {
          console.log(`Trying to connect to service: ${uuid}`);
          const service = await this.server.getPrimaryService(uuid);
          if (service) {
            foundService = service;
            serviceUUID = uuid;
            console.log(`Successfully connected to service: ${uuid}`);
            break;
          }
        } catch (e) {
          console.log(`Service ${uuid} not found on device`);
          
          // Try to convert to 16-bit UUID if it might be a standard BLE UUID
          try {
            // For standard 16-bit UUIDs, like "180d" for Heart Rate
            // Extract the 16-bit part if it's a full UUID
            if (uuid.includes('-')) {
              const shortUuid = uuid.split('-')[0].replace('0000', '');
              if (shortUuid.length === 4) {
                console.log(`Trying 16-bit service UUID: ${shortUuid}`);
                const service = await this.server.getPrimaryService(shortUuid);
                if (service) {
                  foundService = service;
                  serviceUUID = shortUuid;
                  console.log(`Successfully connected to 16-bit service: ${shortUuid}`);
                  break;
                }
              }
            }
          } catch (e2) {
            console.log(`16-bit service ID not found either`);
          }
          // Continue to next service UUID
        }
      }
      
      // If we couldn't find a known service, try to use any available service that has characteristics
      if (!foundService) {
        console.warn('Could not find any known UART/Serial services');
        
        // Try each service to find one with suitable characteristics
        for (const service of allServices) {
          try {
            const characteristics = await service.getCharacteristics();
            console.log(`Service ${service.uuid} has ${characteristics.length} characteristics`);
            
            if (characteristics.length > 0) {
              foundService = service;
              serviceUUID = service.uuid;
              console.log(`Using service ${service.uuid} with ${characteristics.length} characteristics`);
              break;
            }
          } catch (e) {
            console.log(`Could not get characteristics for service ${service.uuid}`);
          }
        }
      }
      
      if (!foundService) {
        throw new Error('Could not find a suitable Bluetooth service for communication');
      }
      
      this.serialService = foundService;
      console.log(`Using service: ${serviceUUID}`);
      this.eventEmitter.emit('bluetooth:connecting', { step: 'service-found', serviceUUID });
      
      // Get characteristics
      this.eventEmitter.emit('bluetooth:connecting', { step: 'characteristics' });
      
      // Try to get TX and RX characteristics using a more flexible approach
      // First, get all characteristics from the service
      console.log('Getting characteristics from service:', this.serialService.uuid);
      let characteristics = [];
      try {
        characteristics = await this.serialService.getCharacteristics();
        console.log('All characteristics:', characteristics.map(c => ({
          uuid: c.uuid,
          properties: Object.keys(c.properties).filter(p => c.properties[p])
        })));
      } catch (error) {
        console.error(`Error getting characteristics: ${error.message}`);
        this.eventEmitter.emit('bluetooth:error', {
          message: `Failed to get characteristics: ${error.message}`,
          error
        });
        throw error;
      }
      
      if (characteristics.length === 0) {
        throw new Error('No characteristics found in the selected service');
      }
      
      // Try with known BLE characteristic pairs first
      // Creating all possible combinations of TX and RX characteristics
      const knownCharacteristicPairs = [];
      
      // Nordic UART pair (most common for BLE UART)
      knownCharacteristicPairs.push({ 
        rx: this.NORDIC_TX_UUID, // The TX characteristic from device
        tx: this.NORDIC_RX_UUID  // The RX characteristic to device
      });
      
      // Try all combinations of TX/RX pairs from our lists
      for (const txUuid of this.BLE_TX_UUIDS) {
        for (const rxUuid of this.BLE_RX_UUIDS) {
          // Skip if it's the same as Nordic pair we already added
          if (txUuid === this.NORDIC_TX_UUID &amp;&amp; rxUuid === this.NORDIC_RX_UUID) {
            continue;
          }
          knownCharacteristicPairs.push({ rx: txUuid, tx: rxUuid });
        }
      }
      
      // Some devices use the same characteristic for both TX and RX
      for (const txUuid of this.BLE_TX_UUIDS) {
        knownCharacteristicPairs.push({ rx: txUuid, tx: txUuid });
      }
      
      // Add legacy SPP pair at the end
      knownCharacteristicPairs.push({ rx: this.SPP_RX_UUID, tx: this.SPP_TX_UUID });
      
      // Try each known pair
      for (const pair of knownCharacteristicPairs) {
        try {
          console.log(`Trying RX=${pair.rx}, TX=${pair.tx}`);
          const rx = await this.serialService.getCharacteristic(pair.rx);
          const tx = await this.serialService.getCharacteristic(pair.tx);
          
          if (rx &amp;&amp; tx) {
            this.rxCharacteristic = rx;
            this.txCharacteristic = tx;
            console.log(`Found matching RX/TX pair: RX=${pair.rx}, TX=${pair.tx}`);
            break;
          }
        } catch (e) {
          console.log(`Characteristic pair not found: ${e.message}`);
          // Continue to next pair
        }
      }
      
      // If we couldn't find a known pair, try to detect based on properties
      if (!this.rxCharacteristic || !this.txCharacteristic) {
        console.log('No known characteristic pair found, detecting based on properties');
        
        // Look for characteristics with the right properties for RX/TX
        // RX: needs notify (for receiving data from device)
        // TX: needs write (for sending data to device)
        const notifyChars = characteristics.filter(char => char.properties.notify);
        const writeChars = characteristics.filter(char => char.properties.write || char.properties.writeWithoutResponse);
        
        console.log(`Found ${notifyChars.length} notify characteristics and ${writeChars.length} write characteristics`);
        
        if (notifyChars.length > 0) {
          this.rxCharacteristic = notifyChars[0];
          console.log(`Using RX characteristic with UUID: ${this.rxCharacteristic.uuid}`);
        } else if (characteristics.length > 0) {
          // Fallback to first characteristic if no notify characteristics
          this.rxCharacteristic = characteristics[0];
          console.log(`Using fallback RX characteristic with UUID: ${this.rxCharacteristic.uuid}`);
        }
        
        if (writeChars.length > 0) {
          this.txCharacteristic = writeChars[0];
          console.log(`Using TX characteristic with UUID: ${this.txCharacteristic.uuid}`);
        } else if (characteristics.length > 1) {
          // Fallback to second characteristic if no write characteristics
          this.txCharacteristic = characteristics[1] || characteristics[0];
          console.log(`Using fallback TX characteristic with UUID: ${this.txCharacteristic.uuid}`);
        } else if (characteristics.length === 1) {
          // If only one characteristic, use it for both TX and RX
          this.txCharacteristic = characteristics[0];
          console.log(`Using single characteristic for both RX and TX: ${this.txCharacteristic.uuid}`);
        }
      }
      
      // Verify we have both characteristics
      if (!this.rxCharacteristic) {
        throw new Error('Could not find a suitable RX characteristic');
      }
      
      if (!this.txCharacteristic) {
        throw new Error('Could not find a suitable TX characteristic');
      }
      
      // Try to start notifications for incoming data
      // But make this optional - some devices might use a polling approach instead
      try {
        console.log(`Starting notifications on RX characteristic: ${this.rxCharacteristic.uuid}`);
        console.log(`RX characteristic properties:`, Object.keys(this.rxCharacteristic.properties).filter(p => this.rxCharacteristic.properties[p]));
        
        // Only attempt to start notifications if the characteristic supports it
        if (this.rxCharacteristic.properties.notify) {
          await this.rxCharacteristic.startNotifications();
          this.rxCharacteristic.addEventListener('characteristicvaluechanged', 
            (event) => this.handleIncomingData(event));
          console.log('Notifications started successfully');
        } else {
          console.log('RX characteristic does not support notifications, will use polling instead');
          // Set up polling for devices that don't support notifications
          this.pollingEnabled = true;
          this.pollingInterval = setInterval(async () => {
            try {
              // Read the characteristic value manually
              if (this.isConnected &amp;&amp; this.rxCharacteristic) {
                const value = await this.rxCharacteristic.readValue();
                // Only process if there's actual data
                if (value &amp;&amp; value.byteLength > 0) {
                  this.handleIncomingData({ target: { value } });
                }
              }
            } catch (e) {
              console.warn('Error polling characteristic:', e);
            }
          }, 500); // Poll every 500ms
        }
      } catch (error) {
        console.error(`Error setting up data reception: ${error.message}`);
        // This is not a fatal error, we can try a different approach
        this.eventEmitter.emit('bluetooth:warning', {
          message: `Could not set up data reception: ${error.message}, will try polling`,
          error
        });
        
        // Set up polling as a fallback
        this.pollingEnabled = true;
        this.pollingInterval = setInterval(async () => {
          try {
            // Read the characteristic value manually
            if (this.isConnected &amp;&amp; this.rxCharacteristic) {
              const value = await this.rxCharacteristic.readValue();
              // Only process if there's actual data
              if (value &amp;&amp; value.byteLength > 0) {
                this.handleIncomingData({ target: { value } });
              }
            }
          } catch (e) {
            console.warn('Error polling characteristic:', e);
          }
        }, 500); // Poll every 500ms
      }
      
      this.isConnected = true;
      this.isConnecting = false;
      this.autoReconnect = options.autoReconnect || false;
      
      this.eventEmitter.emit('bluetooth:connected', {
        deviceId: this.device.id,
        deviceName: this.device.name
      });
      
      return true;
    } catch (error) {
      this.isConnecting = false;
      this.eventEmitter.emit('bluetooth:error', {
        message: error.message,
        error
      });
      
      return false;
    }
  }

  /**
   * Disconnect from the device
   */
  async disconnect() {
    if (!this.isConnected || !this.device) {
      return;
    }
    
    try {
      this.autoReconnect = false;
      
      // Clean up notifications or polling
      if (this.rxCharacteristic &amp;&amp; this.rxCharacteristic.properties.notify) {
        await this.rxCharacteristic.stopNotifications();
      }
      
      // Clear polling interval if it was used
      if (this.pollingEnabled &amp;&amp; this.pollingInterval) {
        clearInterval(this.pollingInterval);
        this.pollingInterval = null;
        this.pollingEnabled = false;
      }
      
      if (this.device.gatt.connected) {
        await this.device.gatt.disconnect();
      }
      
      this.isConnected = false;
      this.eventEmitter.emit('bluetooth:disconnected', {
        deviceId: this.device.id,
        deviceName: this.device.name
      });
    } catch (error) {
      console.error('Error during disconnect:', error);
      this.eventEmitter.emit('bluetooth:error', {
        message: 'Failed to disconnect properly',
        error
      });
    }
  }

  /**
   * Handle device disconnection
   */
  async onDisconnected() {
    const wasConnected = this.isConnected;
    this.isConnected = false;
    
    // Clear polling interval if it was used
    if (this.pollingEnabled &amp;&amp; this.pollingInterval) {
      clearInterval(this.pollingInterval);
      this.pollingInterval = null;
      this.pollingEnabled = false;
    }
    
    this.server = null;
    this.serialService = null;
    this.rxCharacteristic = null;
    this.txCharacteristic = null;
    
    if (wasConnected) {
      this.eventEmitter.emit('bluetooth:disconnected', {
        deviceId: this.device?.id,
        deviceName: this.device?.name
      });
      
      // Attempt automatic reconnection if enabled
      if (this.autoReconnect &amp;&amp; this.device) {
        setTimeout(() => {
          this.connect({ deviceId: this.device.id, autoReconnect: true });
        }, 1000);
      }
    }
  }

  /**
   * Handle incoming data from the device
   * @param {Event} event - Characteristic value changed event
   */
  handleIncomingData(event) {
    try {
      const value = event.target.value;
      const data = value.buffer;
      
      // Convert ArrayBuffer to string for debugging
      const textDecoder = new TextDecoder('utf-8');
      const dataString = textDecoder.decode(new Uint8Array(data));
      
      // Generate a hex representation for debugging
      const hexValues = Array.from(new Uint8Array(data))
        .map(b => b.toString(16).padStart(2, '0'))
        .join(' ');
      
      // Check for empty or extremely short data
      if (dataString.length &lt; 3) {
        console.log(`Received very short data (${dataString.length} bytes), likely not NMEA. Skipping.`);
        return;
      }
      
      // console.log('Received data:', dataString);
      // console.log('Hex representation:', hexValues);
      
      // More comprehensive detection of NMEA data
      const isNmea = dataString.includes('$');
      const containsCrLf = dataString.includes('\r\n');
      const hasNmeaSentence = /\$(GP|GL|GA|GB|GN)[A-Z]{3},/.test(dataString);
      
      // console.log(`Data analysis - NMEA format: ${isNmea}, Contains CR/LF: ${containsCrLf}, Valid NMEA sentence: ${hasNmeaSentence}`);
      
      // Skip data processing if:
      // 1. This appears to be just the device name repeating
      // 2. The device name has already been reported many times
      if (this.lastDataString === dataString &amp;&amp; !isNmea) {
        console.log('Skipping duplicate data (device name)');
        return;
      }
      
      // Remember the last string to detect repeats
      this.lastDataString = dataString;
      
      // Handle potential configuration messages (responses to our PUBX commands)
      if (dataString.includes('PUBX') &amp;&amp; !this.configurationResponded) {
        console.log('Detected configuration response from device:', dataString);
        this.configurationResponded = true;
        
        // Try to enable GGA messages again immediately after receiving a response
        setTimeout(async () => {
          try {
            await this.sendData('$PUBX,40,GGA,1,1,1,1,1,0*5A\r\n');
            console.log('Resent GGA enable command after receiving PUBX response');
          } catch (e) {
            console.warn('Failed to send follow-up command:', e);
          }
        }, 300);
        
        // Try to detect if this includes error information
        if (dataString.toLowerCase().includes('error') || dataString.includes('ERR')) {
          console.warn('Device responded with error to configuration commands');
        } else {
          console.log('Device appears to have accepted configuration');
        }
      }
      
      // Look for UBX binary protocol responses
      if (hexValues.startsWith('b5 62')) {
        console.log('Detected UBX binary protocol response');
        
        // Parse UBX message class and ID
        if (hexValues.length >= 10) {
          const msgClass = parseInt(hexValues.split(' ')[2], 16);
          const msgId = parseInt(hexValues.split(' ')[3], 16);
          console.log(`UBX message class: 0x${msgClass.toString(16)}, ID: 0x${msgId.toString(16)}`);
        }
      }
      
      // Sometimes RMC/GGA sentences are actually present but in unusual format
      // Try to extract them even if not perfectly formatted
      if (isNmea &amp;&amp; !hasNmeaSentence) {
        // Look for position data with regex pattern matching
        const extractedPosition = dataString.match(/(\d{2})(\d{2}\.\d+),([NS]),(\d{3})(\d{2}\.\d+),([EW])/);
        if (extractedPosition) {
          console.log('Found position data in non-standard format:', extractedPosition[0]);
          // Consider constructing a valid NMEA sentence here if needed
        }
      }
      
      // Emit a raw data event with the string, before any parsing
      this.eventEmitter.emit('bluetooth:raw-data', dataString);
      
      // Only emit for parsing if this looks like NMEA data
      if (isNmea) {
        // Emit the binary data for parsing
        this.eventEmitter.emit('bluetooth:data', data);
      }
    } catch (error) {
      console.error('Error handling incoming data:', error);
    }
  }

  /**
   * Send data to the device
   * @param {string|ArrayBuffer} data - Data to send
   * @returns {Promise&lt;boolean>} Whether send was successful
   */
  async sendData(data) {
    if (!this.isConnected || !this.txCharacteristic) {
      console.error('Cannot send data: device not connected or TX characteristic not available');
      return false;
    }
    
    try {
      // Convert string to ArrayBuffer if needed
      let buffer;
      if (typeof data === 'string') {
        if (this.debug.debug) {
          console.log('Sending string data:', data);
        }
        buffer = new TextEncoder().encode(data);
      } else if (data instanceof ArrayBuffer) {
        const textDecoder = new TextDecoder('utf-8');
        const dataString = textDecoder.decode(new Uint8Array(data));
        if (this.debug.debug) {
          console.log('Sending binary data:', dataString);
        }
        buffer = data;
      } else {
        throw new Error('Invalid data type. Expected string or ArrayBuffer');
      }
      
      // When using Nordic UART Service (which is typical for many GNSS devices):
      // The write characteristic might need writeWithoutResponse
      if (this.txCharacteristic.uuid === '6e400002-b5a3-f393-e0a9-e50e24dcca9e') {
        if (this.debug.debug) {
          console.log('Using writeWithoutResponse for Nordic UART TX');
        }
        
        // Break data into smaller chunks (20 bytes max) to avoid overflow
        const MAX_CHUNK_SIZE = 20;
        const dataArray = new Uint8Array(buffer);
        
        for (let i = 0; i &lt; dataArray.length; i += MAX_CHUNK_SIZE) {
          const chunk = dataArray.slice(i, Math.min(i + MAX_CHUNK_SIZE, dataArray.length));
          // Use writeValueWithoutResponse for Nordic UART
          await this.txCharacteristic.writeValueWithoutResponse(chunk);
          
          // Small delay between chunks
          await new Promise(resolve => setTimeout(resolve, 50));
        }
      } 
      // Otherwise try standard methods
      else {
        // Determine the write type based on the characteristic properties
        let writeOptions = {};
        if (this.txCharacteristic.properties.writeWithoutResponse) {
          if (this.debug.debug) {
            console.log('Using writeWithoutResponse');
          }
          writeOptions = { type: 'writeWithoutResponse' };
        } else {
          if (this.debug.debug) {
            console.log('Using standard write');
          }
        }
        
        await this.txCharacteristic.writeValue(buffer, writeOptions);
      }
      
      console.log('Data sent successfully');
      return true;
    } catch (error) {
      console.error('Failed to send data:', error);
      this.eventEmitter.emit('bluetooth:warning', {
        message: `Failed to send data: ${error.message} - continuing operation`,
        error
      });
      // Return true even if sending fails - we want to continue trying to receive data
      // This helps if the device is in a mode where it's sending but not receiving
      return true; 
    }
  }

  /**
   * Send a command to configure the device
   * @param {string} command - Command string
   * @returns {Promise&lt;boolean>} Whether command was sent successfully
   */
  async sendCommand(command) {
    // Ensure command ends with proper line ending
    if (!command.endsWith('\r\n')) {
      command += '\r\n';
    }
    
    return this.sendData(command);
  }

  /**
   * Check if device is connected
   * @returns {boolean} Whether device is connected
   */
  isDeviceConnected() {
    return this.isConnected &amp;&amp; this.device &amp;&amp; this.device.gatt.connected;
  }
  
  /**
   * Special connection method for SparkFun Facet RTK Rover
   * @param {Object} options - Connection options
   * @returns {Promise&lt;boolean>} Whether connection was successful
   */
  async connectToSparkFunFacet(options = {}) {
    if (this.isConnected) {
      return true;
    }
    
    if (this.isConnecting) {
      return false;
    }
    
    this.isConnecting = true;
    this.eventEmitter.emit('bluetooth:connecting', { type: 'sparkfun' });
    
    try {
      // Browser compatibility check
      if (!navigator.bluetooth) {
        throw new Error('Web Bluetooth API is not supported in this browser');
      }
      
      // Create a broader list of optionalServices to improve our chances
      // of finding the correct one for the SparkFun device
      
      // Create a comprehensive list of possible BLE UART services - use only full UUIDs
      const allPossibleServices = [
        // The specific known SparkFun service (this may vary by device model)
        '0000ffe0-0000-1000-8000-00805f9b34fb', // Common for HC-05/06/08 modules
        
        // Common UART services in priority order
        '6e400001-b5a3-f393-e0a9-e50e24dcca9e', // Nordic UART Service
        '49535343-fe7d-4ae5-8fa9-9fafd205e455', // HM-10 Service
        '0000fff0-0000-1000-8000-00805f9b34fb', // Alternative UART Service
        
        // Generic services
        '00001800-0000-1000-8000-00805f9b34fb', // Generic Access
        '00001801-0000-1000-8000-00805f9b34fb', // Generic Attribute
        
        // Add all other service UUIDs we know about
        ...this.SERVICE_UUIDS,
        
        // Try some common UUID patterns with different bases
        '0000180a-0000-1000-8000-00805f9b34fb', // Device Information
        '00001809-0000-1000-8000-00805f9b34fb', // Health Thermometer
        '0000180d-0000-1000-8000-00805f9b34fb', // Heart Rate
        '0000180f-0000-1000-8000-00805f9b34fb', // Battery Service
        '0000181a-0000-1000-8000-00805f9b34fb'  // Environmental Sensing
      ];
      
      // Request device with Facet specific filters
      const requestOptions = {
        filters: [
          { namePrefix: 'Facet' },
          { namePrefix: 'SparkFun' },
          { namePrefix: 'RTK' }
        ],
        optionalServices: allPossibleServices
      };
      
      // Show device picker
      console.log('Requesting SparkFun Facet RTK device...');
      this.device = await navigator.bluetooth.requestDevice(requestOptions);
      
      if (!this.device) {
        throw new Error('No device selected');
      }
      
      // Set up disconnection listener
      this.device.addEventListener('gattserverdisconnected', this.onDisconnected);
      
      // Connect to GATT server
      console.log('Connecting to GATT server...');
      this.server = await this.device.gatt.connect();
      
      // Get all available services
      console.log('Getting all services...');
      const allServices = await this.server.getPrimaryServices();
      
      if (allServices.length === 0) {
        throw new Error('No services found on device');
      }
      
      console.log('Available services:', allServices.map(s => s.uuid));
      
      // Find a service we can use for communication
      // Create a priority list of services to try - use only full UUIDs
      const priorityServices = [
        // First priority: Known UART/Serial services
        '0000ffe0-0000-1000-8000-00805f9b34fb', // BLE UART (HC-05/06/08)
        '0000ffe5-0000-1000-8000-00805f9b34fb', // BLE Data Service
        '6e400001-b5a3-f393-e0a9-e50e24dcca9e', // Nordic UART
        '49535343-fe7d-4ae5-8fa9-9fafd205e455', // HM-10/16/17
        '0000fff0-0000-1000-8000-00805f9b34fb', // HC-08/10 Alternative
        
        // Generic services - lowest priority
        '00001800-0000-1000-8000-00805f9b34fb', // Generic Access 
        '00001801-0000-1000-8000-00805f9b34fb'  // Generic Attribute
      ];
      
      // Log all available services for debugging
      console.log('Available services on device:');
      allServices.forEach(service => {
        console.log(`- ${service.uuid}`);
      });
      
      // Try each service in priority order
      for (const serviceId of priorityServices) {
        const service = allServices.find(s => s.uuid === serviceId);
        if (service) {
          console.log(`Found priority service: ${serviceId}`);
          this.serialService = service;
          break;
        }
      }
      
      // If we still don't have a service, try all services
      if (!this.serialService) {
        console.log('No priority service found, trying all services...');
        
        // Try each service and see if it has suitable characteristics
        for (const service of allServices) {
          try {
            const chars = await service.getCharacteristics();
            console.log(`Service ${service.uuid} has ${chars.length} characteristics`);
            
            // Look for characteristics with read property (needed for data reception)
            const readChar = chars.find(c => c.properties.read);
            if (readChar) {
              console.log(`Found service with readable characteristic: ${service.uuid}`);
              this.serialService = service;
              break;
            }
          } catch (e) {
            console.warn(`Error checking characteristics for service ${service.uuid}:`, e);
          }
        }
        
        // Last resort: use the first service
        if (!this.serialService &amp;&amp; allServices.length > 0) {
          console.log('Using first available service as last resort');
          this.serialService = allServices[0];
        }
      }
      
      if (!this.serialService) {
        throw new Error('Could not find a suitable service');
      }
      
      console.log('Using service:', this.serialService.uuid);
      
      // Get all characteristics from this service
      console.log('Getting characteristics...');
      const characteristics = await this.serialService.getCharacteristics();
      
      if (characteristics.length === 0) {
        throw new Error('No characteristics found');
      }
      
      console.log('Available characteristics:', characteristics.map(c => ({
        uuid: c.uuid,
        properties: Object.keys(c.properties).filter(p => c.properties[p])
      })));
      
      // For SparkFun devices, we'll prioritize characteristics with read/write permissions
      this.rxCharacteristic = characteristics.find(char => char.properties.read);
      this.txCharacteristic = characteristics.find(char => char.properties.write || char.properties.writeWithoutResponse);
      
      // If we couldn't find a read characteristic, use the first available
      if (!this.rxCharacteristic &amp;&amp; characteristics.length > 0) {
        this.rxCharacteristic = characteristics[0];
      }
      
      // If we couldn't find a write characteristic, use the second available or the first one
      if (!this.txCharacteristic &amp;&amp; characteristics.length > 1) {
        this.txCharacteristic = characteristics[1];
      } else if (!this.txCharacteristic) {
        this.txCharacteristic = characteristics[0];
      }
      
      console.log('Using RX characteristic:', this.rxCharacteristic.uuid);
      console.log('Using TX characteristic:', this.txCharacteristic.uuid);
      
      // Set up enhanced polling for SparkFun device with better error recovery
      console.log('Setting up enhanced polling for SparkFun device...');
      this.pollingEnabled = true;
      
      // For some devices, we need to try multiple characteristics
      // Get all characteristics from this service
      let allCharacteristics = [];
      try {
        // Get all characteristics for potential polling targets
        allCharacteristics = await this.serialService.getCharacteristics();
        console.log(`Found ${allCharacteristics.length} characteristics to potentially poll`);
      } catch (e) {
        console.warn('Error getting all characteristics:', e);
      }
      
      // Track failure count to potentially switch characteristics
      let failureCount = 0;
      const MAX_FAILURES = 3;
      let currentCharIndex = 0;
      let dataReceived = false;
      let startupDelay = true;
      
      // Give device time to initialize before starting polling
      setTimeout(() => {
        startupDelay = false;
        console.log('Starting data polling after initialization delay');
      }, 3000);
      
      // Use a more robust polling approach with two methods
      this.pollingInterval = setInterval(async () => {
        // Skip polling during startup delay
        if (startupDelay) {
          return;
        }
        
        try {
          // Try notification method first (preferred)
          if (this.isConnected &amp;&amp; this.rxCharacteristic &amp;&amp; this.rxCharacteristic.properties.notify) {
            if (!this.rxCharacteristic._hasStartedNotifications) {
              try {
                await this.rxCharacteristic.startNotifications();
                this.rxCharacteristic._hasStartedNotifications = true;
                console.log('Successfully started notifications on characteristic');
                
                // Add event listener for notifications
                this.rxCharacteristic.addEventListener('characteristicvaluechanged', 
                  (event) => this.handleIncomingData(event));
              } catch (notifyError) {
                console.warn('Failed to start notifications, falling back to polling:', notifyError);
              }
            }
          }
          
          // Also use direct readValue as backup or alternative
          if (this.isConnected &amp;&amp; this.rxCharacteristic) {
            const value = await this.rxCharacteristic.readValue();
            // Only process if there's actual data
            if (value &amp;&amp; value.byteLength > 0) {
              this.handleIncomingData({ target: { value } });
              
              // Track successful data receipt
              if (!dataReceived) {
                dataReceived = true;
                console.log('Successfully receiving data from device');
              }
              
              failureCount = 0; // Reset failure count on success
            } else {
              // Empty value could be a soft failure
              failureCount++;
            }
          }
        } catch (e) {
          console.warn('Error polling primary characteristic:', e);
          failureCount++;
          
          // If we've had multiple failures, try switching to another characteristic
          if (failureCount >= MAX_FAILURES &amp;&amp; allCharacteristics.length > 1) {
            failureCount = 0;
            currentCharIndex = (currentCharIndex + 1) % allCharacteristics.length;
            
            // Try using a different characteristic
            const nextChar = allCharacteristics[currentCharIndex];
            if (nextChar &amp;&amp; nextChar !== this.rxCharacteristic) {
              console.log(`Switching to alternative characteristic: ${nextChar.uuid}`);
              this.rxCharacteristic = nextChar;
              
              // Reset notification tracking for this characteristic
              this.rxCharacteristic._hasStartedNotifications = false;
              
              // Try to start notifications for the new characteristic
              try {
                await this.rxCharacteristic.startNotifications();
                this.rxCharacteristic._hasStartedNotifications = true;
                console.log('Successfully started notifications on new characteristic');
                
                // Add event listener for notifications on the new characteristic
                this.rxCharacteristic.addEventListener('characteristicvaluechanged', 
                  (event) => this.handleIncomingData(event));
                
                // Try to enable GGA messages again with the new characteristic
                setTimeout(async () => {
                  try {
                    // Send specific command with this new characteristic
                    await this.sendData('$PUBX,40,GGA,1,1,1,1,1,0*5A\r\n');
                    console.log('Resent GGA enable command on new characteristic');
                  } catch (e) {
                    console.warn('Failed to send command on new characteristic:', e);
                  }
                }, 500);
              } catch (notifyError) {
                console.warn('Failed to start notifications on new characteristic, continuing with polling');
              }
            }
          }
        }
      }, 250); // Poll more frequently (125ms) for better responsiveness
      
      // Device is now connected
      this.isConnected = true;
      this.isConnecting = false;
      this.autoReconnect = options.autoReconnect || false;
      
      // Nordic UART commands - specifically for SparkFun device
      // Since we know we're already receiving GSA sentences, we'll just try to enable GGA
      setTimeout(async () => {
        try {
          console.log('Sending NMEA configuration commands for Nordic UART (SparkFun)...');
          
          // First wait a full 2 seconds for the device to stabilize its connection
          await new Promise(resolve => setTimeout(resolve, 2000));
          
          console.log('Connection stabilized, beginning command sequence');
          
          // First send some line breaks to wake it up - important for some modules
          await this.sendData('\r\n\r\n');
          await new Promise(resolve => setTimeout(resolve, 500));
          
          // Send reset command - try to start from a clean state
          // This will revert settings to defaults but ensure consistent behavior
          await this.sendData('$PUBX,40,ZDA,0,0,0,0,0,0*45\r\n');
          await new Promise(resolve => setTimeout(resolve, 300));
          
          // Send the configuration commands in the exact order used by other applications
          // GGA sentence - position data (must be first and with higher rate)
          await this.sendData('$PUBX,40,GGA,0,1,0,0,0,0*5A\r\n');
          await new Promise(resolve => setTimeout(resolve, 500));
          
          // GGA sentence again with different parameters - matches working app's sequence
          await this.sendData('$PUBX,40,GGA,1,1,1,1,1,0*5A\r\n');
          await new Promise(resolve => setTimeout(resolve, 500));
          
          // RMC sentence - minimum navigation info
          await this.sendData('$PUBX,40,RMC,1,1,1,1,1,0*47\r\n');
          await new Promise(resolve => setTimeout(resolve, 500));
          
          // GSA sentence - satellite data
          await this.sendData('$PUBX,40,GSA,1,1,1,1,1,0*4E\r\n');
          await new Promise(resolve => setTimeout(resolve, 500));
          
          // GST sentence - error statistics 
          await this.sendData('$PUBX,40,GST,1,1,1,1,1,0*5B\r\n');
          await new Promise(resolve => setTimeout(resolve, 500));
          
          // VTG sentence - course and speed
          await this.sendData('$PUBX,40,VTG,1,1,1,1,1,0*5E\r\n');
          await new Promise(resolve => setTimeout(resolve, 500));
          
          // Save configuration to persist changes
          await this.sendData('$PUBX,00*33\r\n');
          await new Promise(resolve => setTimeout(resolve, 1000));
          
          // Alternative command method that works on some u-blox devices
          // Set message rate directly using CFG-MSG
          const ubxCfgMsgGGA = new Uint8Array([
            0xB5, 0x62,            // Header
            0x06, 0x01,            // CFG-MSG class/id
            0x08, 0x00,            // Payload length
            0xF0, 0x00,            // NMEA GGA message class/id
            0x01,                  // Enable on port 0 (I2C)
            0x01,                  // Enable on port 1 (UART1)
            0x01,                  // Enable on port 2 (UART2)
            0x01,                  // Enable on port 3 (USB)
            0x01,                  // Enable on port 4 (SPI)
            0x00,                  // Reserved
            0x02, 0x32             // Checksum
          ]);
          
          // Try to send the binary command
          try {
            await this.sendData(ubxCfgMsgGGA.buffer);
            await new Promise(resolve => setTimeout(resolve, 500));
          } catch (e) {
            console.log('Binary command failed, continuing with NMEA commands');
          }
          
          // Query current configuration to trigger response
          await this.sendData('$PUBX,00*33\r\n');
          await new Promise(resolve => setTimeout(resolve, 300));
          
          console.log('Complete NMEA configuration commands sent');
        } catch (e) {
          console.warn('Error sending NMEA configuration - device may be in read-only mode:', e);
          console.log('Continuing with available data');
        }
      }, 1000);
      
      this.eventEmitter.emit('bluetooth:connected', {
        deviceId: this.device.id,
        deviceName: this.device.name,
        type: 'sparkfun'
      });
      
      return true;
    } catch (error) {
      this.isConnecting = false;
      this.eventEmitter.emit('bluetooth:error', {
        message: error.message,
        error,
        type: 'sparkfun'
      });
      
      return false;
    }
  }

  /**
   * Get connection status information
   * @returns {Object} Connection status
   */
  getConnectionInfo() {
    return {
      connected: this.isConnected,
      connecting: this.isConnecting,
      deviceId: this.device?.id,
      deviceName: this.device?.name
    };
  }
}

export default BluetoothConnection;</code></pre></article></section></div></div></div><div class="search-container" id="PkfLWpAbet" style="display:none"><div class="wrapper" id="iCxFxjkHbP"><button class="icon-button search-close-button" id="VjLlGakifb" aria-label="close search"><svg><use xlink:href="#close-icon"></use></svg></button><div class="search-box-c"><svg><use xlink:href="#search-icon"></use></svg> <input type="text" id="vpcKVYIppa" class="search-input" placeholder="Search..." autofocus></div><div class="search-result-c" id="fWwVHRuDuN"><span class="search-result-c-text">Type anything to view search result</span></div></div></div><div class="mobile-menu-icon-container"><button class="icon-button" id="mobile-menu" data-isopen="false" aria-label="menu"><svg><use xlink:href="#menu-icon"></use></svg></button></div><div id="mobile-sidebar" class="mobile-sidebar-container"><div class="mobile-sidebar-wrapper"><div class="mobile-nav-links"></div><div class="mobile-sidebar-items-c"><div class="sidebar-section-title with-arrow" data-isopen="false" id="sidebar-classes"><div>Classes</div><svg><use xlink:href="#down-icon"></use></svg></div><div class="sidebar-section-children-container"><div class="sidebar-section-children"><a href="BluetoothConnection.html">BluetoothConnection</a></div><div class="sidebar-section-children"><a href="ConnectionHandler.html">ConnectionHandler</a></div><div class="sidebar-section-children"><a href="ConnectionManager.html">ConnectionManager</a></div><div class="sidebar-section-children"><a href="DeviceSettings.html">DeviceSettings</a></div><div class="sidebar-section-children"><a href="EventEmitter.html">EventEmitter</a></div><div class="sidebar-section-children"><a href="GnssModule.html">GnssModule</a></div><div class="sidebar-section-children"><a href="NmeaParser.html">NmeaParser</a></div><div class="sidebar-section-children"><a href="NtripClient.html">NtripClient</a></div><div class="sidebar-section-children"><a href="RtkSettings.html">RtkSettings</a></div><div class="sidebar-section-children"><a href="RtkStatus.html">RtkStatus</a></div><div class="sidebar-section-children"><a href="Settings.html">Settings</a></div><div class="sidebar-section-children"><a href="SettingsPage.html">SettingsPage</a></div></div></div><div class="mobile-navbar-actions"><div class="navbar-right-item"><button class="icon-button search-button" aria-label="open-search"><svg><use xlink:href="#search-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button theme-toggle" aria-label="toggle-theme"><svg><use class="theme-svg-use" xlink:href="#light-theme-icon"></use></svg></button></div><div class="navbar-right-item"><button class="icon-button font-size" aria-label="change-font-size"><svg><use xlink:href="#font-size-icon"></use></svg></button></div></div></div></div><script type="text/javascript" src="scripts/core.min.js"></script><script src="scripts/search.min.js" defer="defer"></script><script src="scripts/third-party/fuse.js" defer="defer"></script><script type="text/javascript">var tocbotInstance=tocbot.init({tocSelector:"#eed4d2a0bfd64539bb9df78095dec881",contentSelector:".main-content",headingSelector:"h1, h2, h3",hasInnerContainers:!0,scrollContainer:".main-content",headingsOffset:130,onClick:bringLinkToView})</script></body></html>